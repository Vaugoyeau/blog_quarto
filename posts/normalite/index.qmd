---
title: "La loi normale"
author: "Marie Vaugoyeau"
date: "2022/11/22"
date-format: "D MMMM YYYY"
categories: [twitch, Rnewbies, analyse de donn√©es, statistiques]
toc: true
toc-title: Sur cette page
---

[![](pont_eiffel.png){fig-align="center"}](https://500px.com/p/antoinemach?view=photos)

::: {.callout-note icon="false"}
**Twitch du 22 novembre 2022** La vid√©o n'est malheureusment plus disponible suite √† une erreur de manipulation ü´£\
Code disponible sur [GitHub](https://github.com/Vaugoyeau/twitch_loi_normale)
:::

```{r}
#| label = "setup",
#| include = FALSE
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```
  
```{r}
#| label: "initialisation et fixation de la graine al√©atoire"

library(tidyverse)

# fixe la graine √† 105
set.seed(105)

```
  
# Introduction  
## Les lois de proababilit√©s  
Une loi de probabilit√© revient √† **pr√©voir** le comportement d'une exp√©rience al√©atoire. Les grandes lois de probabilit√© sont bas√©es sur le fonctionnement de jeu de hasard et ont √©t√© ensuite formalis√©es.  
Naturellement, tout le monde comprend que lorsqu'on joue √† lancer une pi√®ce (√©quilibr√©e) au hasard, chacune des faces √† autant de chance de sortir.  
Il est impossible de pr√©voir le nombre de piles et de faces pour un petit nombre de lancers, par exemple six.  
Par contre, plus ce nombre augmente, plus on peut pr√©voir le nombre de fois que le c√¥t√© face va sortir, car le nombre de lancers √©quilibre le r√©sultat.  
  
```{r}
#| label = "lancer_pieces"
# cr√©ation d'un vecteur contenant le nombre de lancers
nb_lancers <- c(
  1:9, # 1, 2, 3... 9
  seq(from = 10, to = 100, by = 10), # 10, 20... 100
  seq(from = 200, to = 1000, by = 100) # 200, 300... 1000
)

# 10 simulations pour chaque valeurs de nb_lancers de pi√®ces
purrr::map(
  c(1:10),
  ~ bind_rows(
    bind_cols(
      nb_lancers = nb_lancers,
      nb_lancers %>% 
        purrr::map(
          ~ rbinom(.x, 1, 0.5)
        ) %>% 
        purrr::map(sum) %>% 
        purrr::map(as_tibble) %>% 
        bind_rows() %>% 
        rename(nb_faces = value)
    )
  )
) %>% 
  bind_rows() %>% # mise en commun des lignes
  mutate(
    pourcentage_face = nb_faces /nb_lancers # calcul du pourcentage de r√©ussites
  ) %>% # cr√©ation du graphique
  ggplot() + 
  aes(y = nb_lancers, x = pourcentage_face, group = nb_lancers) +
  geom_boxplot(color = "grey") + # ajout des bo√Ætes √† moustaches
  geom_jitter() + # ajout des points
  scale_x_log10() + # choix d'une √©chelle logarthmique
  theme_classic() +
  labs(
    y = "Nombre de lancers de pi√®ce (√©chelle logarithmique)",
    x = "Nombre de faces (%)"
  )

```
  
## Origine de la loi normale  
Si la loi de probabilit√© uniforme est la plus intuitive, la loi de probabilit√© normal est la **plus couramment utilis√©e**. En effet, c'est celle qui est la plus proche des **ph√©nom√®nes biologiques**.  

::: {.callout-note icon="false"}
**La loi normale** est aussi appel√©e **loi gaussienne**, **loi de Gauss** ou **de Laplace-Gauss** des noms de Laplace et Gauss, deux scientifiques du XVIII√®me si√®cle qui l'ont √©tudi√©e.  
:::  
  
Contrairement aux lois binomiales et de Poisson, la loi normale est une loi de probabilit√© continue d√©finie par deux param√®tres : son esp√©rance (¬µ) et sa variance (œÉ). Sa densit√© de probabilit√© s'√©crit comme suit.  
Si X ‚àΩ Œù(Œº,œÉ¬≤) alors $$ f(x)=\frac{1}{(œÉ‚àö2œÄ)}{e^{\frac{-1}{2} ({\frac{x-Œº}{œÉ})^2}}} $$ pour tous $$ x ‚àà {R^+} $$  
C'est une densit√© de probabilit√© et non une fonction de masse qui permet de la d√©finir.  
La densit√© de probabilit√© est sym√©trique, le centre √©tant l'esp√©rance, l'√©cart-type la largeur du pic comme visible sur la figure.  
  
```{r}
#| label = "loi_normale"

# choix de l'intervalle de repr√©sentation
intervalle <- seq(-15, 15, 0.1)

# loi normale de param√®tres ¬µ √©gale √† -5, -3, 0 ou 3 et œÉ √©gale √† 2, 0.8, 1 ou 3
tibble(
  loi_normale = 
    rep(
      c(
        "¬µ = 0 & \U03B4 = 1", 
        "¬µ = 3 & \U03B4 = 3", 
        "¬µ = -3 & \U03B4 = 0.8", 
        "¬µ = -5 & \U03B4 = 2"
      ), 
      each = length(intervalle)
    ),
  x = rep(intervalle, 4),
  densite = 
    c(
      dnorm(intervalle, mean = 0, sd = 1),
      dnorm(intervalle, mean = 3, sd = 3),
      dnorm(intervalle, mean = -3, sd = 0.8),
      dnorm(intervalle, mean = -5, sd = 2))
) %>% 
  ggplot() +
  aes(x = x, y = densite, color = loi_normale) +
  geom_line(size = 1) +
  theme_classic() +
  scale_color_manual(values = c("blue", "dark red", "black", "gold")) +
  ylab("densite de probabilit√© (f(x))") +
  labs(color = "Loi normale")

ggsave("img/loi_normale.png")

```
  
## Approximation  
Les √©v√®nements al√©atoires quel qu‚Äôils soient, rendent impossible la pr√©diction exacte.  
Cela signifie que quand on rejette √† 5%, dans 5 cas sur 100, c'est vrai mais on le rejette quand m√™me !  
```{r}
#| label = "expl_loi_normale_test_bi_uni_lateral"

# choix de l'intervalle de repr√©sentation
intervalle <- seq(-5, 5, 0.1)

# test bilat√©ral
bilateral <- tibble(
  x = intervalle,
  "densit√©" = dnorm(intervalle, mean = 0, sd = 1),
  region = 
    case_when(
      x < qnorm(0.025) ~ "r√©gion critique basse",
      x < qnorm(0.975) ~ "r√©gion de confiance",
      TRUE ~ "r√©gion critique haute"
    )
) %>% 
  ggplot() +
  aes(x = x, y = `densit√©`) +
  geom_line(size = 1) +
  geom_area(aes(fill = region)) +
  scale_fill_manual(values = c("blue", "red", "green")) +
  geom_vline(xintercept = qnorm(0.025), size = 1, linetype = "dashed") + 
  geom_vline(xintercept = qnorm(0.975), size = 1, linetype = "dashed") + 
  geom_text(aes(x = -4, y = 0.06, label = "2,5 % des valeurs")) +
  geom_text(aes(x = 4, y = 0.06, label = "2,5 % des valeurs")) +
  geom_text(aes(x = 0, y = 0.42, label = "95 % des valeurs")) +
  theme_classic()

# test unilat√©ral √† gauche
unilateral_gauche <- tibble(
  x = intervalle,
  "densit√©" = dnorm(intervalle, mean = 0, sd = 1),
  region = 
    case_when(
      x < qnorm(0.05) ~ "r√©gion critique basse",
      TRUE ~ "r√©gion de confiance"
    )
) %>% 
  ggplot() +
  aes(x = x, y = `densit√©`) +
  geom_line(size = 1) +
  geom_area(aes(fill = region)) +
  scale_fill_manual(values = c("blue", "green")) +
  geom_vline(xintercept = qnorm(0.05), size = 1, linetype = "dashed") + 
  geom_text(aes(x = -3.5, y = 0.06, label = "5 % des valeurs"), size = 2) +
  geom_text(aes(x = 0, y = 0.42, label = "95 % des valeurs"), size = 2) +
  theme_classic() +
  theme(legend.position = "none")

# test unilat√©ral √† droite
unilateral_droit <- tibble(
  x = intervalle,
  "densit√©" = dnorm(intervalle, mean = 0, sd = 1),
  region = 
    case_when(
      x > qnorm(0.95) ~ "r√©gion critique haute",
      TRUE ~ "r√©gion de confiance"
    )
) %>% 
  ggplot() +
  
  aes(x = x, y = `densit√©`) +
  geom_line(size = 1) +
  geom_area(aes(fill = region)) +
  scale_fill_manual(values = c("red", "green")) +
  geom_vline(xintercept = qnorm(0.95), size = 1, linetype = "dashed") + 
  geom_text(aes(x = 3.5, y = 0.06, label = "5 % des valeurs"), size = 2) +
  geom_text(aes(x = 0, y = 0.42, label = "95 % des valeurs"), size = 2) +
  theme_classic() +
  theme(legend.position = "none")

library(cowplot)
ggdraw() +
  draw_plot(bilateral, 0, .5, 1, .5) +
  draw_plot(unilateral_gauche, 0, 0, .5, .5) +
  draw_plot(unilateral_droit, .5, 0, .5, .5)

```
Sur les graphiques les parties rouges et bleues sont vraies mais on les rejette.  
  
## Utilit√© de la loi normale  
Un grand nombre de tests est bas√© sur des donn√©es suivant une loi normale : ACP, mod√®le lin√©aire, ANOVA...   
Si les donn√©es ne suivent pas de loi normale il ne faut pas faire ses tests !  
  
# Iris : jeu de donn√©es utilis√©  
Iris est un jeu de donn√©es avec les longueurs et largeurs de p√©tales et s√©pales mesur√©es sur 150 fleurs d'iris selon trois esp√®ces (50 fleurs par esp√®ce).  
  
```{r}
#| label = "visualisation_du_jeu_de_donnees"

iris %>% View()

iris %>% 
  ggplot() +
  aes(x = Petal.Length) +
  geom_histogram()

```

  
# Le test de Shapiro-Wilk  
## Le test d'hypoht√®ses  
### *1√®re √©tape : D√©finir les hypoth√®ses*  
Hypoth√®se nulle, H0 : les donn√©es suivent une loi normale   
Hypoth√®se alternative, H1 : les donn√©es ne suivent pas une loi normale  
  
### *2√®me √©tape : Formaliser math√©matiquement les hypoth√®ses*  
H0 : X -> N(¬µ, œÉ¬≤)  
H1 : X -->- N(¬µ, œÉ¬≤)  
  
### *3√®me √©tape : Tester si l‚Äôhypoth√®se nulle est probable ou doit-√™tre rejet√©e*  
Si la p-valeur > 0.05, H0 n'est pas rejet√© donc les donn√©es suivent une loi normale (√† v√©rifier graphiquement)  
Sinon les donn√©es ne suivent pas une loi normale.  
  
## La statistique de test  
$$ {\displaystyle W= {\left (\sum \limits _ {i=1}^ {n}a_ {i}x_ { (i)}\right)^ {2} \over \sum \limits _ {i=1}^ {n} (x_ {i}- {\overline {x}})^ {2}}} $$
  
## R√©alisation du test  
Le test de Shapiro-Wilk ne peut pas √™tre utilis√© quand il y a plus de 5000 valeurs.  
Il doit √™tre utilis√© sur un vecteur et non sur une table enti√®re.  
```{r}
#| label = "test_shapiro",
#| error = TRUE

shapiro.test(rnorm(n = 6000, mean = 5, sd = 3))

shapiro.test(
  iris$Petal.Length
)

ggplot(iris) +
  aes(x = Petal.Length, fill = Species) +
  geom_histogram(bins = 35)

shapiro.test((iris %>% filter(Species == "setosa"))$Petal.Length)

shapiro.test((iris %>% filter(Species == "versicolor"))$Petal.Length)

iris %>% 
  filter(Species == "setosa") %>% 
  ggplot(aes(x = Petal.Length)) +
  geom_histogram()

iris %>% 
  filter(Species == "versicolor") %>% 
  ggplot(aes(x = Petal.Length)) +
  geom_histogram()

```
  
# QQplot  
## Objectif du QQplot  
Tester la normalit√© des donn√©es graphiquement en repr√©sentant les donn√©es r√©elles et celles attendus selon une loi normale.  
  
## R√©alisation du graphique  
```{r}
#| label = "qqplot"
iris %>%
  ggplot() +
  aes(sample = Petal.Length) +
  geom_qq() +
  geom_qq_line(color = "dark red", size = 1) +
  theme_classic()

iris %>%
  filter(Species == "setosa") %>% 
  ggplot() +
  aes(sample = Petal.Length) +
  geom_qq() +
  geom_qq_line(color = "dark red", size = 1) +
  theme_classic()

iris %>% 
  filter(Species == "versicolor") %>% 
  ggplot() +
  aes(sample = Petal.Length) +
  geom_qq() +
  geom_qq_line() +
  theme_classic()

```



