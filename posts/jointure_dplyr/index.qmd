---
title: "Jointure de tables avec `{dplyr}`"
author: "Marie Vaugoyeau"
date: "2024/06/25"
date-format: "D MMMM YYYY"
categories: [twitch, Rnewbies, tidyverse, analyse de donn√©es]
toc: true
toc-title: Sur cette page
---

[![](joint.png){fig-align="center"}](https://500px.com/p/antoinemach?view=photos)

::: {.callout-note icon="false"}
[**Twitch du 25 juin 2024**](https://www.twitch.tv/videos/2181295529).\
Le son est en double au d√©but mais cela s'arr√™te au bout de 2 minutes, d√©sol√©e pour le soucis üòÖ

Code disponible sur [GitHub](https://github.com/Vaugoyeau/twitch_jointure_dplyr).
:::

# Les donn√©es

## Import des packages

```{r}
library(tidyverse)
```

## Temp√©rature quotidienne

Les donn√©es sont [les temp√©ratures quotidiennes d√©partementales](https://www.data.gouv.fr/fr/datasets/temperature-quotidienne-departementale-depuis-janvier-2018/) t√©l√©charg√©e directement depuis le site.

```{r}
# import des donn√©es
temperature <- read_delim("https://www.data.gouv.fr/fr/datasets/r/dd0df06a-85f2-4621-8b8b-5a3fe195bcd7", delim = ";")

# ajout mois et ann√©e
temperature <- read_delim("https://www.data.gouv.fr/fr/datasets/r/dd0df06a-85f2-4621-8b8b-5a3fe195bcd7", delim = ";") |>
  mutate(
    mois = month(date_obs),
    annee = year(date_obs)
  )
  
# calcul des valeurs mensuelles
temperature <- read_delim("https://www.data.gouv.fr/fr/datasets/r/dd0df06a-85f2-4621-8b8b-5a3fe195bcd7", delim = ";") |>
  mutate(
    mois = month(date_obs),
    annee = year(date_obs)
  ) |> 
  group_by(departement, mois, annee) |> 
  summarise(
    tmin = min(tmin, na.rm = TRUE),
    tmax = max(tmax, na.rm = TRUE),
    tmoy = mean(tmoy, na.rm = TRUE)
  ) |> 
  ungroup()
```

## Densit√© de population par d√©partements

Ainsi que les [donn√©es de densit√©s par d√©partements](https://www.insee.fr/fr/statistiques/6683035?sommaire=6683037).

```{r}
#| eval: false

download.file("https://www.insee.fr/fr/statistiques/fichier/6683035/ensemble.zip", destfile = "data_raw/insee.zip", mode = "wb") 

unzip("data_raw/insee.zip",exdir = "data_raw")
```

```{r}
info_departement <- read_delim("data_raw/donnees_departements.csv", delim =";")
```

```{r}
#| eval: false
file.remove(glue::glue("data_raw/{list.files('data_raw')}"))
```

# Concat√©nation de tables

## Pourquoi ?

Pour coupler des informations pr√©sentes dans diff√©rentes tables pour explorer le lien, par exemple les variations de temp√©ratures en fonction de la densit√© de population.

## Probl√®me

Pour que les jointures se passent bien, il faut que les informations pr√©sentes dans une table correspondent √† celles pr√©sentes dans l'autre !

## Diff√©rents types de jointures

Prenons deux tables :

```{r}
(A <- tibble(
  id = letters[1:3],
  w = c(5, 9, 7),
  x= c(1, 4, 8)
))


(B <- tibble(
  id = letters[c(1, 2, 4)],
  y = c(4, 7, 6),
  z = c(2, 8, 6)
  ) 
)

```

On veut avoir les informations `r letters[23:26]` pour tous les individus -\> **jointure totale** avec `full_join()` de `{dplyr}`

```{r}
full_join(A, B)
```

On veut que les lignes des individus pr√©sents dans les deux tableaux -\> **jointure interne** avec `inner_join()` de `{dplyr}`

```{r}
inner_join(A, B)
```

On veut toutes les caract√©ristiques disponibles pour les individus d'une des deux tables -\> **jointure √† gauche** ou **√† droite** avec `left_join()` et `right_join()` de `{dplyr}`. Le sens de la jointure a une influence dans l'ordre des tables mais fait la m√™me chose si on inverse l'ordre, seules les colonnes ne seront pas dans le m√™me ordre.

::: callout-note
## Pour r√©organiser les colonnes

Il est possible d'utiliser la fonction `relocate()` du package `{dplyr}`.
:::

```{r}
left_join(A, B)
right_join(B, A)

# r√©organisation des colonnes
right_join(B, A) |> 
  relocate(id, letters[23:26])

left_join(B, A)

# r√©organisation des colonnes
left_join(B, A) |> 
  relocate(letters[23:26], .after = id)

right_join(A, B)

```

On veut les individus qui ne sont pas pr√©sent dans l'autre table -\> **anti-jointure** avec `anti_join()` de `{dplyr}`.\
L'ordre √† son importance, ce sont les individus de la premi√®re table qui ne sont pas pr√©sent dans la deuxi√®me qui sortent.

```{r}
anti_join(A, B)

anti_join(B, A)
```

# Pr√©paration des donn√©es en amont

## Identification de la cl√© de jointure

Si pas d√©faut les fonctions prennent comme cl√© de jointure les colonnes qui ont le m√™me nom, ce n'est pas n√©cessairement ce que l'on veut obtenir.\
La cl√© peut √™tre bas√© sur une ou plusieurs colonnes.

```{r}
glimpse(info_departement)
glimpse(temperature)
```

Ici : `DEP` == `departement`

## M√™me type d'objets

Les donn√©es doivent-√™tre de m√™me type donc la v√©rification de la classe des cl√©s est indispensable.

```{r}
class(info_departement$DEP) == class(temperature$departement)
```

## Pr√©sence de doublons

La d√©tection des doublons se fait facilement gr√¢ce √† la fonction `count()` de `{dplyr}`.

```{r}
info_departement |> 
  count(DEP) |> 
  arrange(n)

temperature |> 
  count(departement) |> 
  filter(n != 78)

```

## Pr√©sence de valeurs manquantes

L'utilisation conjugu√©e de la fonction `is.na()` du package `{base}` dans la fonction `filter()` de `{dplyr}` permet de trier facilement les lignes avec des valeurs manquantes.

```{r}
info_departement |> 
  filter(is.na(DEP))

temperature |> 
  filter(is.na(departement))

```

Ce n'est pas n√©cessairement un probl√®me **d'avoir des doublons** ou **des valeurs manquantes** mais il faut que cela correspondent √† ce que l'on souhaite faire.

# Jointure total avec `full_join()`

## R√©alisation de la jointure

```{r}
jointure_total <- full_join(
  info_departement,
  temperature,
  by = join_by(DEP == departement)
  )

```

## V√©rification de la table cr√©e

Calcul de la taille attendue

```{r}

dim(info_departement)
dim(temperature)

# calcul du nombre de colonnes attendue
ncol(info_departement) + ncol(temperature) - 1 == ncol(jointure_total)

# v√©rification du nombre de lignes
nrow(temperature) == nrow(jointure_total)

```

## Recherche des `NA`

```{r}
jointure_total |> 
  filter(is.na(CODREG))

jointure_total |> 
  filter(is.na(mois)) |> 
  View()

```

## Utilisation de l'anti-jointure

Possibilit√© d'utiliser l'anti-jointure pour identifier les lignes √† probl√®me

```{r}

anti_join(
  info_departement,
  temperature,
  by = join_by(DEP == departement)
)

anti_join(
  temperature,
  info_departement,
  by = join_by(departement == DEP)
)

```

# Jointure interne avec `inner_join()`

## Cr√©ation de la jointure la plus stricte

```{r}
jointure_interne <- inner_join(
  info_departement,
  temperature,
  by = join_by(DEP == departement)
)

# m√™me r√©sultat avec la jointure √† droite
jointure_a_droite <- right_join(
  info_departement,
  temperature,
  by = join_by(DEP == departement)
)

# v√©rification  
identical(jointure_a_droite, jointure_interne)

```

## V√©rification de la jointure interne

```{r}

jointure_a_droite |> 
  count(DEP) |> 
  filter(n != 78)

```
