{
  "hash": "acd54d4d734b662e739c290f641658ae",
  "result": {
    "markdown": "---\ntitle: \"La loi normale\"\nauthor: \"Marie Vaugoyeau\"\ndate: \"2022/11/22\"\ndate-format: \"D MMMM YYYY\"\ncategories: [twitch, Rnewbies, analyse de donn√©es, statistiques]\ntoc: true\ntoc-title: Sur cette page\n---\n\n\n[![](pont_eiffel.png){fig-align=\"center\"}](https://500px.com/p/antoinemach?view=photos)\n\n::: {.callout-note icon=\"false\"}\n**Twitch du 22 novembre 2022** La vid√©o n'est malheureusment plus disponible suite √† une erreur de manipulation ü´£\\\nCode disponible sur [GitHub](https://github.com/Vaugoyeau/twitch_loi_normale)\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# fixe la graine √† 105\nset.seed(105)\n```\n:::\n\n  \n# Introduction  \n## Les lois de proababilit√©s  \nUne loi de probabilit√© revient √† **pr√©voir** le comportement d'une exp√©rience al√©atoire. Les grandes lois de probabilit√© sont bas√©es sur le fonctionnement de jeu de hasard et ont √©t√© ensuite formalis√©es.  \nNaturellement, tout le monde comprend que lorsqu'on joue √† lancer une pi√®ce (√©quilibr√©e) au hasard, chacune des faces √† autant de chance de sortir.  \nIl est impossible de pr√©voir le nombre de piles et de faces pour un petit nombre de lancers, par exemple six.  \nPar contre, plus ce nombre augmente, plus on peut pr√©voir le nombre de fois que le c√¥t√© face va sortir, car le nombre de lancers √©quilibre le r√©sultat.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\n# cr√©ation d'un vecteur contenant le nombre de lancers\nnb_lancers <- c(\n  1:9, # 1, 2, 3... 9\n  seq(from = 10, to = 100, by = 10), # 10, 20... 100\n  seq(from = 200, to = 1000, by = 100) # 200, 300... 1000\n)\n\n# 10 simulations pour chaque valeurs de nb_lancers de pi√®ces\npurrr::map(\n  c(1:10),\n  ~ bind_rows(\n    bind_cols(\n      nb_lancers = nb_lancers,\n      nb_lancers %>% \n        purrr::map(\n          ~ rbinom(.x, 1, 0.5)\n        ) %>% \n        purrr::map(sum) %>% \n        purrr::map(as_tibble) %>% \n        bind_rows() %>% \n        rename(nb_faces = value)\n    )\n  )\n) %>% \n  bind_rows() %>% # mise en commun des lignes\n  mutate(\n    pourcentage_face = nb_faces /nb_lancers # calcul du pourcentage de r√©ussites\n  ) %>% # cr√©ation du graphique\n  ggplot() + \n  aes(y = nb_lancers, x = pourcentage_face, group = nb_lancers) +\n  geom_boxplot(color = \"grey\") + # ajout des bo√Ætes √† moustaches\n  geom_jitter() + # ajout des points\n  scale_x_log10() + # choix d'une √©chelle logarthmique\n  theme_classic() +\n  labs(\n    y = \"Nombre de lancers de pi√®ce (√©chelle logarithmique)\",\n    x = \"Nombre de faces (%)\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/lancer_pieces-1.png){width=672}\n:::\n:::\n\n  \n## Origine de la loi normale  \nSi la loi de probabilit√© uniforme est la plus intuitive, la loi de probabilit√© normal est la **plus couramment utilis√©e**. En effet, c'est celle qui est la plus proche des **ph√©nom√®nes biologiques**.  \n\n::: {.callout-note icon=\"false\"}\n**La loi normale** est aussi appel√©e **loi gaussienne**, **loi de Gauss** ou **de Laplace-Gauss** des noms de Laplace et Gauss, deux scientifiques du XVIII√®me si√®cle qui l'ont √©tudi√©e.  \n:::  \n  \nContrairement aux lois binomiales et de Poisson, la loi normale est une loi de probabilit√© continue d√©finie par deux param√®tres : son esp√©rance (¬µ) et sa variance (œÉ). Sa densit√© de probabilit√© s'√©crit comme suit.  \nSi X ‚àΩ Œù(Œº,œÉ¬≤) alors $$ f(x)=\\frac{1}{(œÉ‚àö2œÄ)}{e^{\\frac{-1}{2} ({\\frac{x-Œº}{œÉ})^2}}} $$ pour tous $$ x ‚àà {R^+} $$  \nC'est une densit√© de probabilit√© et non une fonction de masse qui permet de la d√©finir.  \nLa densit√© de probabilit√© est sym√©trique, le centre √©tant l'esp√©rance, l'√©cart-type la largeur du pic comme visible sur la figure.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\n# choix de l'intervalle de repr√©sentation\nintervalle <- seq(-15, 15, 0.1)\n\n# loi normale de param√®tres ¬µ √©gale √† -5, -3, 0 ou 3 et œÉ √©gale √† 2, 0.8, 1 ou 3\ntibble(\n  loi_normale = \n    rep(\n      c(\n        \"¬µ = 0 & \\U03B4 = 1\", \n        \"¬µ = 3 & \\U03B4 = 3\", \n        \"¬µ = -3 & \\U03B4 = 0.8\", \n        \"¬µ = -5 & \\U03B4 = 2\"\n      ), \n      each = length(intervalle)\n    ),\n  x = rep(intervalle, 4),\n  densite = \n    c(\n      dnorm(intervalle, mean = 0, sd = 1),\n      dnorm(intervalle, mean = 3, sd = 3),\n      dnorm(intervalle, mean = -3, sd = 0.8),\n      dnorm(intervalle, mean = -5, sd = 2))\n) %>% \n  ggplot() +\n  aes(x = x, y = densite, color = loi_normale) +\n  geom_line(size = 1) +\n  theme_classic() +\n  scale_color_manual(values = c(\"blue\", \"dark red\", \"black\", \"gold\")) +\n  ylab(\"densite de probabilit√© (f(x))\") +\n  labs(color = \"Loi normale\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/loi_normale-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggsave(\"img/loi_normale.png\")\n```\n:::\n\n  \n## Approximation  \nLes √©v√®nements al√©atoires quel qu‚Äôils soient, rendent impossible la pr√©diction exacte.  \nCela signifie que quand on rejette √† 5%, dans 5 cas sur 100, c'est vrai mais on le rejette quand m√™me !  \n\n::: {.cell}\n\n```{.r .cell-code}\n# choix de l'intervalle de repr√©sentation\nintervalle <- seq(-5, 5, 0.1)\n\n# test bilat√©ral\nbilateral <- tibble(\n  x = intervalle,\n  \"densit√©\" = dnorm(intervalle, mean = 0, sd = 1),\n  region = \n    case_when(\n      x < qnorm(0.025) ~ \"r√©gion critique basse\",\n      x < qnorm(0.975) ~ \"r√©gion de confiance\",\n      TRUE ~ \"r√©gion critique haute\"\n    )\n) %>% \n  ggplot() +\n  aes(x = x, y = `densit√©`) +\n  geom_line(size = 1) +\n  geom_area(aes(fill = region)) +\n  scale_fill_manual(values = c(\"blue\", \"red\", \"green\")) +\n  geom_vline(xintercept = qnorm(0.025), size = 1, linetype = \"dashed\") + \n  geom_vline(xintercept = qnorm(0.975), size = 1, linetype = \"dashed\") + \n  geom_text(aes(x = -4, y = 0.06, label = \"2,5 % des valeurs\")) +\n  geom_text(aes(x = 4, y = 0.06, label = \"2,5 % des valeurs\")) +\n  geom_text(aes(x = 0, y = 0.42, label = \"95 % des valeurs\")) +\n  theme_classic()\n\n# test unilat√©ral √† gauche\nunilateral_gauche <- tibble(\n  x = intervalle,\n  \"densit√©\" = dnorm(intervalle, mean = 0, sd = 1),\n  region = \n    case_when(\n      x < qnorm(0.05) ~ \"r√©gion critique basse\",\n      TRUE ~ \"r√©gion de confiance\"\n    )\n) %>% \n  ggplot() +\n  aes(x = x, y = `densit√©`) +\n  geom_line(size = 1) +\n  geom_area(aes(fill = region)) +\n  scale_fill_manual(values = c(\"blue\", \"green\")) +\n  geom_vline(xintercept = qnorm(0.05), size = 1, linetype = \"dashed\") + \n  geom_text(aes(x = -3.5, y = 0.06, label = \"5 % des valeurs\"), size = 2) +\n  geom_text(aes(x = 0, y = 0.42, label = \"95 % des valeurs\"), size = 2) +\n  theme_classic() +\n  theme(legend.position = \"none\")\n\n# test unilat√©ral √† droite\nunilateral_droit <- tibble(\n  x = intervalle,\n  \"densit√©\" = dnorm(intervalle, mean = 0, sd = 1),\n  region = \n    case_when(\n      x > qnorm(0.95) ~ \"r√©gion critique haute\",\n      TRUE ~ \"r√©gion de confiance\"\n    )\n) %>% \n  ggplot() +\n  \n  aes(x = x, y = `densit√©`) +\n  geom_line(size = 1) +\n  geom_area(aes(fill = region)) +\n  scale_fill_manual(values = c(\"red\", \"green\")) +\n  geom_vline(xintercept = qnorm(0.95), size = 1, linetype = \"dashed\") + \n  geom_text(aes(x = 3.5, y = 0.06, label = \"5 % des valeurs\"), size = 2) +\n  geom_text(aes(x = 0, y = 0.42, label = \"95 % des valeurs\"), size = 2) +\n  theme_classic() +\n  theme(legend.position = \"none\")\n\nlibrary(cowplot)\nggdraw() +\n  draw_plot(bilateral, 0, .5, 1, .5) +\n  draw_plot(unilateral_gauche, 0, 0, .5, .5) +\n  draw_plot(unilateral_droit, .5, 0, .5, .5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/expl_loi_normale_test_bi_uni_lateral-1.png){width=672}\n:::\n:::\n\nSur les graphiques les parties rouges et bleues sont vraies mais on les rejette.  \n  \n## Utilit√© de la loi normale  \nUn grand nombre de tests est bas√© sur des donn√©es suivant une loi normale : ACP, mod√®le lin√©aire, ANOVA...   \nSi les donn√©es ne suivent pas de loi normale il ne faut pas faire ses tests !  \n  \n# Iris : jeu de donn√©es utilis√©  \nIris est un jeu de donn√©es avec les longueurs et largeurs de p√©tales et s√©pales mesur√©es sur 150 fleurs d'iris selon trois esp√®ces (50 fleurs par esp√®ce).  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\niris %>% View()\n\niris %>% \n  ggplot() +\n  aes(x = Petal.Length) +\n  geom_histogram()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/visualisation_du_jeu_de_donnees-1.png){width=672}\n:::\n:::\n\n\n  \n# Le test de Shapiro-Wilk  \n## Le test d'hypoht√®ses  \n### *1√®re √©tape : D√©finir les hypoth√®ses*  \nHypoth√®se nulle, H0 : les donn√©es suivent une loi normale   \nHypoth√®se alternative, H1 : les donn√©es ne suivent pas une loi normale  \n  \n### *2√®me √©tape : Formaliser math√©matiquement les hypoth√®ses*  \nH0 : X -> N(¬µ, œÉ¬≤)  \nH1 : X -->- N(¬µ, œÉ¬≤)  \n  \n### *3√®me √©tape : Tester si l‚Äôhypoth√®se nulle est probable ou doit-√™tre rejet√©e*  \nSi la p-valeur > 0.05, H0 n'est pas rejet√© donc les donn√©es suivent une loi normale (√† v√©rifier graphiquement)  \nSinon les donn√©es ne suivent pas une loi normale.  \n  \n## La statistique de test  \n$$ {\\displaystyle W= {\\left (\\sum \\limits _ {i=1}^ {n}a_ {i}x_ { (i)}\\right)^ {2} \\over \\sum \\limits _ {i=1}^ {n} (x_ {i}- {\\overline {x}})^ {2}}} $$\n  \n## R√©alisation du test  \nLe test de Shapiro-Wilk ne peut pas √™tre utilis√© quand il y a plus de 5000 valeurs.  \nIl doit √™tre utilis√© sur un vecteur et non sur une table enti√®re.  \n\n::: {.cell}\n\n```{.r .cell-code}\nshapiro.test(rnorm(n = 6000, mean = 5, sd = 3))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in shapiro.test(rnorm(n = 6000, mean = 5, sd = 3)): la taille de l'√©chantillon doit √™tre comprise entre 3 et 5000\n```\n:::\n\n```{.r .cell-code}\nshapiro.test(\n  iris$Petal.Length\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tShapiro-Wilk normality test\n\ndata:  iris$Petal.Length\nW = 0.87627, p-value = 7.412e-10\n```\n:::\n\n```{.r .cell-code}\nggplot(iris) +\n  aes(x = Petal.Length, fill = Species) +\n  geom_histogram(bins = 35)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/test_shapiro-1.png){width=672}\n:::\n\n```{.r .cell-code}\nshapiro.test((iris %>% filter(Species == \"setosa\"))$Petal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tShapiro-Wilk normality test\n\ndata:  (iris %>% filter(Species == \"setosa\"))$Petal.Length\nW = 0.95498, p-value = 0.05481\n```\n:::\n\n```{.r .cell-code}\nshapiro.test((iris %>% filter(Species == \"versicolor\"))$Petal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tShapiro-Wilk normality test\n\ndata:  (iris %>% filter(Species == \"versicolor\"))$Petal.Length\nW = 0.966, p-value = 0.1585\n```\n:::\n\n```{.r .cell-code}\niris %>% \n  filter(Species == \"setosa\") %>% \n  ggplot(aes(x = Petal.Length)) +\n  geom_histogram()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/test_shapiro-2.png){width=672}\n:::\n\n```{.r .cell-code}\niris %>% \n  filter(Species == \"versicolor\") %>% \n  ggplot(aes(x = Petal.Length)) +\n  geom_histogram()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/test_shapiro-3.png){width=672}\n:::\n:::\n\n  \n# QQplot  \n## Objectif du QQplot  \nTester la normalit√© des donn√©es graphiquement en repr√©sentant les donn√©es r√©elles et celles attendus selon une loi normale.  \n  \n## R√©alisation du graphique  \n\n::: {.cell}\n\n```{.r .cell-code}\niris %>%\n  ggplot() +\n  aes(sample = Petal.Length) +\n  geom_qq() +\n  geom_qq_line(color = \"dark red\", size = 1) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/qqplot-1.png){width=672}\n:::\n\n```{.r .cell-code}\niris %>%\n  filter(Species == \"setosa\") %>% \n  ggplot() +\n  aes(sample = Petal.Length) +\n  geom_qq() +\n  geom_qq_line(color = \"dark red\", size = 1) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/qqplot-2.png){width=672}\n:::\n\n```{.r .cell-code}\niris %>% \n  filter(Species == \"versicolor\") %>% \n  ggplot() +\n  aes(sample = Petal.Length) +\n  geom_qq() +\n  geom_qq_line() +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/qqplot-3.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}