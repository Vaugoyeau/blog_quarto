{
  "hash": "f7dd42bb446a2acf8773511a52842e41",
  "result": {
    "markdown": "---\ntitle: \"Initiation à `Shiny`\"\nauthor: \"Marie Vaugoyeau\"\ndate: \"2024/01/12\"\ndate-format: \"D MMMM YYYY\"\ncategories: [twitch, Rnewbies, shiny]\ntoc: true\ntoc-title: Sur cette page\n---\n\n\n[![](mont_saint_michel.png){fig-align=\"center\"}](https://500px.com/p/antoinemach?view=photos)\n\n::: {.callout-note icon=\"false\"}\n[**Twitch du 12 janvier 2024**](https://www.twitch.tv/videos/2030237577).\n\nCode disponible sur [GitHub](https://github.com/Vaugoyeau/twitch_shiny).\n:::\n\n# C'est quoi `Shiny` ?  \n  \n[![](img/logo_shiny.jpeg){width=10%}](https://shiny.posit.co/)  \n  \n`Shiny` est un package `R` qui permet de construire facilement des application type web.  \n  \n::: callout-tip\n## Définition : Une application    \n  \nC'est un objet informatique **manipulable directement, en ligne et sans installation**.  \nIl n'y a pas de nécessité à déployer sur le web.  \nL'application peut tourner en local sur un ordinateur ou un serveur.  \n:::\n  \nAvant `Shiny`, il était nécessaire d'avoir une bonne connaissance des technologies du web (`HTML`, `CSS`,...).  \n  \n`Shiny` permet de :  \n  \n-   Générer simplement le `front-end`, **l'interface utilisateur.trice** et le `back-end`, la **structure** sans apprendre de langage web  \n-   Faire des **tableaux de bords** mais aussi des **pages web** pour communiquer les résultats  \n-   Mettre en place une analyse de données en libre service    \n-   Gérer des cartes, des tableaux, des graphiques, des questionnaires...  \n   \n   \n# Etapes de création d'une application  \n  \n-   *Avoir une idée* : Cela paraît évident mais développer une appli prends du temps donc si on n'a pas d'idée forte derrière c'est encore plus long.    \n-   *Documenter les besoins et attentes des utilisateur.trice.s* : Même si tu es ton utilisateur.trice il est nécessaire de lister ce dont tu as besoin pour cette application.    \n-   *Relier les besoins et attentes à des actions* : Une fois les besoins rassemblés dans un seul fichier, il est nécessaire de lister ce qu'il va falloir faire.    \n-   *Lister les données nécessaires* : Action et besoins vont permettre de décrire les données nécessaires dans l'appli.    \n-   *Réaliser une maquette simple* : Il est important de prévoir à quoi ressemblera la futur appli.    \n-   *Coder l'application*  \n-   *Faire tourner en local*  \n-   Déployer l'application (non traité ici)  \n  \n# Préparation de l'application  \n## Le blueprint  \nLes besoins et attentes peuvent être documentés suite à des interviews, des discussions, des rapports. Cela peut vite devenir chronophage avec la démultiplication des sources.  \n  \nIl est important de les lister dans un unique fichier.    \nCe fichier doit-être construit et validé par les participant.e.s au projet.  \nLe blueprint doit contenir les besoins utilisateurs mais aussi les actions à réaliser associer à chaque besoin.  \nIl faut aussi les relier aux données nécessaire pour y répondre.  \n  \n## Exemple de blueprint  \n  \n|                   **Besoins utilisateurs**                    |          **Action à réaliser**          |                 **Données nécessaires**                 |\n|:-----------------------:|:--------------------:|:----------------------:|\n| Visualiser l'évolution de la taille de la colonie bactérienne |  Réalisation et affichage du graphique  |       Nombre de cellules selon la date de mesure        |\n|                                                               |                                         |                                                         |\n|            Sélection de l'environnement de culture            | Liste déroulant avec les environnements | Type d'environnement et filtre appliqué sur les données |\n  \n## Maquetter l'application avec un Mock-up   \n  \n::: callout-tip\n## Idée principale\n  \nReprésenter la structure de la future application  \n:::\n    \nLa maquette s'appuie sur le blueprint. Elle doit prendre en compte les besoins des utilisateurs-trices et les actions à réaliser.  \nBien sûr, la maquette évolue au cours de la vie de l'application.  \n  \n\n![](img/Mockup.jpg){width=30%} ![](img/Example-of-a-mockup.png){width=30%}  \n\n![](img/New-Personal-Portfolio-App-Mockup.png){width=40%}  \n  \n  \n# Comprendre la structure de l'application Shiny  \n  \nToutes les applications ont :  \n\n-   une partie `User Interface` qui permet de gérer le `Front-End`, c'est-à-dire à quoi l'**application ressemble**  \n-   une partie `Server` qui gère le `Back-End`, c'est-à-dire les mécanismes sous jacents ou **que fait l'application**   \n  \n::: callout-note  \n## A retenir  \n  \nDans une application Shiny, l'interface utilisateur.trice est géré par la fonction ou le fichier `ui` et les coulisses par la fonction ou le fichier `Server`.  \n:::\n\n![](img/server_ui.png)  \n  \n# Miroir des fonctions `output` / `render`  \n| **ui** | **server** |  \n|:-----------------------:|:--------------------:|\n| `plotOutput()` | `renderPlot()` |  \n| `textOutput()` | `renderText()` |  \n| `dataTableOutput()` du package `{DT}` | `renderDataTable()` du package `{DT}` |  \n| `leafletOutput()` du package `{leaflet}` | `renderLeaflet()` du package `{leaflet}` |  \n| | |\n| `sliderInput()` <br> `dateInput()` <br> `checkboxInput()` <br>  `textInput()` <br> `passewordInput()`| `input$nom_de_l_input` |  \n  \n::: callout-tip  \n## Nommer un input  \n   \nLes identifiant des `input` peuvent contenir des lettres, des nombres et des underscores `_`, rien d'autre.  \nIls sont nécessairement **uniques** !  \n:::\n  \n# Créer une application dans un projet  \n  \nEnsemble créons une première application dans un projet grâce à `New projet` > `New Directory` > `Shiny Application`.  \n  \n::: callout-tip\n## Et maintenant ? \n  \nExplorons ensemble cette application.  \n:::\n \n \n# Application d'un thème  \nLors du live, j'ai utilisé la fonction `themeSelector()` du package `{shinythemes}` pour tester différents thèmes disponibles.  \n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  \n  shinythemes::themeSelector(),\n\n  titlePanel(\"Graphique Old Faithful Geyser Data\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"bins\",\n                  \"Number of bins:\",\n                  min = 1,\n                  max = 50,\n                  value = 30)\n    ),\n    \n    # Show a plot of the generated distribution\n    mainPanel(\n      plotOutput(\"distPlot\")\n    )\n  )\n)\n```\n:::\n\n  \nJ'ai aussi appliqué un thème choisi dans le package `{bslib}` qui est associé à `Bootstrap`.  \n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  \n  theme = bslib::bs_theme(bootswatch = \"minty\"),\n\n  titlePanel(\"Graphique Old Faithful Geyser Data\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"bins\",\n                  \"Number of bins:\",\n                  min = 1,\n                  max = 50,\n                  value = 30)\n    ),\n    \n    # Show a plot of the generated distribution\n    mainPanel(\n      plotOutput(\"distPlot\")\n    )\n  )\n)\n```\n:::\n\n  \n::: callout-caution  \n## Shiny permet de se passer de `Bootstrap`  \n  \n`Bootstrap` est un ensemble d'outils qui permet d'intégrer aux applications des boutons, des éléments interactifs...  \nIl est codé en `HTML`, `CSS` et `JavaScript`  \n:::\n  \n# Ajout d'onglet   \nJ'en ai très rapidement parlé lors du live, il est possible de rajouter des onglets pour structurer l'appli. Ils peuvent être rajouter à différents niveaux mais aussi horizontalement et verticalement.  \nCe que j'ai utiliser dans le live c'est `navlistPanel()` qui présente les titres dans une barre latérale :  \n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  \n  theme = bslib::bs_theme(bootswatch = \"minty\"),\n\n  navlistPanel(\n    tabPanel(\n      \"Graphique Old Faithful Geyser Data\",\n      sidebarLayout(\n        sidebarPanel(\n          sliderInput(\"bins\",\n                      \"Number of bins:\",\n                      min = 1,\n                      max = 50,\n                      value = 30)\n        ),\n        \n        # Show a plot of the generated distribution\n        mainPanel(\n          plotOutput(\"distPlot\")\n        )\n      )\n    ),\n    tabPanel(\n      \"plotly\",\n      plotlyOutput(\"mon_graphique\")\n    )\n  )\n)\n```\n:::\n\n  \n# Ajout d'un graphique `ggplot` avec l'intéractivité via `{plotly}`  \nIl est conseillé de créer le graphique avant de le rendre intéractif grâce à `{plotly}`.  \nLe graphique sera appelé dans la partie `ui` grâce à la fonction `plotlyOutput()` et créer dans la partie `sevrer` grâce à la fonction `renderPlotly()` grâce au package `{plotly}`.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nui <- fluidPage(\n  \n  theme = bslib::bs_theme(bootswatch = \"minty\"),\n\n  navlistPanel(\n    tabPanel(\n      \"Graphique Old Faithful Geyser Data\",\n      sidebarLayout(\n        sidebarPanel(\n          sliderInput(\"bins\",\n                      \"Number of bins:\",\n                      min = 1,\n                      max = 50,\n                      value = 30)\n        ),\n        \n        # Show a plot of the generated distribution\n        mainPanel(\n          plotOutput(\"distPlot\")\n        )\n      )\n    ),\n    tabPanel(\n      \"plotly\",\n      plotlyOutput(\"mon_graphique\")\n    )\n  )\n)\n\n# Define server logic required to draw a histogram\nserver <- function(input, output) {\n\n    output$distPlot <- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    <- faithful[, 2]\n        bins <- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n    \n    graphique_ggplot <- ggplot(iris) +\n      aes(x = Petal.Width, y =  Petal.Length, color = Species) + \n      geom_point(alpha = 0.4) +\n      geom_smooth(method = \"lm\") +\n      theme_classic()\n    \n    output$mon_graphique <- renderPlotly(graphique_ggplot)\n}\n```\n:::\n\n\n  \n# Des ressources pour utiliser `Shiny`  \n`Shiny` est porté par [![](img/Posit-Logo.jpg){width=10%}](https://shiny.posit.co/) (anciennement RStudio)   \nSur le site, il y a des [tutoriels](https://shiny.posit.co/r/getstarted/shiny-basics/lesson1/index.html) et pleins d'exemples sont disponibles dans la [galerie de Shiny](https://shiny.posit.co/r/gallery/) avec le code associé.     \n  \n  \n# Pour aller plus loin    \nPour plus d'information sur la réactivité :  \n   \n- [**Le guide complet pour comprendre la réactivité en Shiny** par Charles   BORDET](https://www.charlesbordet.com/fr/reactive-shiny/#)  \n- [Le chapitre **Mastering reactivity** de **Mastering Shiny** par Hadley Wickham](https://mastering-shiny.org/reactivity-intro.html)  \n- [Le chapitre **Best practices** de **Mastering Shiny** par Hadley Wickham](https://mastering-shiny.org/scaling-intro.html)  \n- Pour une réactivité spécifique aux cartes, il est conseillé d'utiliser le package [`{leafletProxy}`](https://rstudio.github.io/leaflet/shiny.html)   \n  \nEt d'autres packages cools :  \n  \n- [`{shinymanager}`](https://datastorm-open.github.io/shinymanager/) : package pour créer un accès sécurisé  \n- [`{webR}`]() : Package qui permet de coder en R dans un navigateur. Pour d'informations pour l'utiliser afin de déployer une appli Shiny :   \n    - [*Build serverless shiny application via Github page* article de blog de **R-posts.com**](http://r-posts.com/build-serverless-shiny-application-via-github-page/)  \n    - [*Preloading your R packages in webR in an Express JS API article de blog* écrit par Colin FAY](https://colinfay.me/preloading-your-r-packages-in-webr-in-an-express-js-api/)  \n  ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}