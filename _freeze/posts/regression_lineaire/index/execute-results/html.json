{
  "hash": "17ab8600d9a66af2046c18d6128ce31d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Apprendre à réaliser une régression linéaire\"\nauthor: \"Marie Vaugoyeau\"\ndate: \"2024/12/17\"\ndate-format: \"D MMMM YYYY\"\ncategories: [twitch, Rnewbies, analyse de données, statistiques]\ntoc: true\ntoc-title: Sur cette page\n---\n\n\n[![](bateau.png){fig-align=\"center\"}](https://500px.com/p/antoinemach?view=photos)\n\n::: {.callout-note icon=\"false\"}\n[**Twitch du 17 décembre 2024**](https://www.twitch.tv/videos/2329095656).\\\n\nCode disponible sur [GitHub](https://github.com/Vaugoyeau/twitch_regression_lineaire).\n:::\n\n# import des packages  \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n# Définition de la `régression linéaire`  \n\n**Objectif** : Trouver une équation de type linéaire qui permet d'expliquer une **variable réponse quantitative** par **une ou plusieurs variable(s) explicative(s)**.   \n\n:::callout-note\n## Différence entre régression linéaire et modèle linéaire  \n\nIl n'y en a pas !  \nCertaines personnes parlent de **modèle de régression linéaire**.  \n:::\n\nL'équation est de la forme : $$ Y = aX + b $$ \nAvec `a : la pente (ou coefficient directeur)` et `b : l'ordonnée à l'origine ou intecept`  \n  \n![](img/reg_lin.png)  \n  \n:::callout-warning\n## Attention  \n\nLa régression de `Y` en fonction de `X` n'est pas la même que la régression de `X` en fonction de `Y`.  \n:::  \n\n![](img/sens_reg.png)  \n  \n# Etude des résidus  \nPour ajuste la droite de régression, la méthode utilisée se base sur les **résidus** : **la méthode des moindres carrées**.  \nLa somme du carré des résidus est calculée à chaque itération (création d'une nouvelle équation) et comparée aux autre. \nL'idée est d'avoir la plus petite somme des résidus possible.    \n  \n::: callout-note  \n## Les résidus \n\nUn résidu est la **différence** entre la **valeur observée** et la **valeur prédite par l'équation linéaire**.  \n:::\n  \n  \n![](img/residu.png)  \n  \nLes résidus doivent suivre une loi normale, vérifiable grâce à un `graphique quantile-quantile` (`QQplot`) ou le test de `Shapiro-Wilk`.  \nPlus d'information sur la loi normale dans [cet article de blog](https://mvaugoyeau.netlify.app/posts/normalite/).  \n  \n# Les points extrêmes  \nIl y a deux sortes d'extrêmes :  \n  \n- **Extrême sur Y** : ordonnée très différente des autres points d’abscisse proche -> **Point non consistant**  \n\n::: {.cell}\n\n```{.r .cell-code}\nanscombe |> \n  ggplot() +\n  aes(x = x3, y = y3) +\n  geom_point() +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n- **Extrême sur X** : abscisse nettement plus petite ou plus grande que celle des autres points -> **Phénomène de levier**  \n\n::: {.cell}\n\n```{.r .cell-code}\nanscombe |> \n  ggplot() +\n  aes(x = x4, y = y4) +\n  geom_point() +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n  \n::: callout-warning  \n## Point influent  \n  \nDans les deux cas, un point est **influent** lorsque la régression pratiquée avec ou sans ce point conduit à des résultats très différents.  \n:::\n  \n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nanscombe |> \n  ggplot() +\n  aes(x = x3, y = y3) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Avec point consistant](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\nanscombe |> \n  filter(y3 < 10) |> \n  ggplot() +\n  aes(x = x3, y = y3) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Sans point consitant](index_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n\n```{.r .cell-code}\nanscombe |> \n  ggplot() +\n  aes(x = x4, y = y4) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Avec point levier](index_files/figure-html/unnamed-chunk-4-3.png){width=672}\n:::\n\n```{.r .cell-code}\nanscombe |> \n  filter(x4 < 10) |> \n  ggplot() +\n  aes(x = x4, y = y4) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Sans point levier](index_files/figure-html/unnamed-chunk-4-4.png){width=672}\n:::\n:::\n\n  \n# Les données  \nLes données utilisées sont celles du jeu de données [`iris`](https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/iris). Les longueurs et largeurs de sépales et pétales ont été mesurées sur 50 iris de 3 espèces, plus d'information sur la page d'aide `help(iris)`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  \n 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  \n Median :5.800   Median :3.000   Median :4.350   Median :1.300  \n Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  \n 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  \n Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  \n       Species  \n setosa    :50  \n versicolor:50  \n virginica :50  \n                \n                \n                \n```\n\n\n:::\n:::\n\n  \n# Réalisation d'une régression linéaire  \n## 1^ère^ étape : Réalisation d'un nuage de points   \n  \nLa visualisation des données est une étape indispensable afin de **vérifier les données** et de **contrôler la linéarité** des données.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris) +\n  aes(x = Sepal.Length, y = Sepal.Width) +\n  geom_point() +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n  \n::: callout-warning\n## Attention  \n  \nIl ne faut pas réaliser de régression linéaire si graphiquement on ne distingue pas de relation linéaire entre les données.  \n:::  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris) +\n  aes(x = Petal.Length, y = Petal.Width) +\n  geom_point() +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n## 2^ème^ étape : Vérifier les limites d'utilisation de la régression     \nLes données doivent être indépendantes et suivre (ou être approximées par) des lois normales.  \n  \nTest de Shapiro-Wilk\n\n::: {.cell}\n\n```{.r .cell-code}\nshapiro.test(iris$Petal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tShapiro-Wilk normality test\n\ndata:  iris$Petal.Length\nW = 0.87627, p-value = 7.412e-10\n```\n\n\n:::\n\n```{.r .cell-code}\nshapiro.test(iris$Petal.Width)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tShapiro-Wilk normality test\n\ndata:  iris$Petal.Width\nW = 0.90183, p-value = 1.68e-08\n```\n\n\n:::\n:::\n\n  \n::: callout-note\nLes longueurs et largeurs de pétales ne suivent pas des lois normales.  \n:::\n\nReprésentation graphique  \n\n::: {.cell}\n\n```{.r .cell-code}\niris |> \n  ggplot() +\n  aes(sample = Petal.Length) +\n  geom_qq() +\n  geom_qq_line() +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\niris |> \n  pivot_longer(\n    cols = - Species\n  ) |> \n  ggplot() +\n  aes(sample = value) +\n  geom_qq() +\n  geom_qq_line() +\n  facet_wrap(~ name, scales = \"free\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n:::\n\n  \n:::callout-note  \nLa régression linéaire est assez résistante à l'absence de normalité et il est possible de la faire ici en prenant en compte [**la loi des grands nombres**](https://fr.wikipedia.org/wiki/Loi_des_grands_nombres).  \n:::\n  \n## 3^ème^ étape : Création du modèle linéaire  \nPlusieurs packages ont des fonctions qui permettent de réaliser un modèle linéaire.  \nIci je vais rester sur la fonction `lm()` du package `{stats}` automatiquement chargé dans l'environnement.  \nCette fonction prend comme premier argument la `formula`, c'est-à-dire la formule de type `y ~ x` et en deuxième argument `data`, le jeu de données utilisé.  \n\n::: {.cell}\n\n```{.r .cell-code}\nmodele_lineaire_petale <- lm(\n  Petal.Width ~ Petal.Length,\n  data = iris\n)\n```\n:::\n\n\nPour accéder aux coefficients, il y a plusieurs solutions :  \n\n- Rappeler le nom du modèle : Ne donne pas les statistiques de test    \n- Utiliser la fonction `summary()` du package `{base}` : Le plus complet mais attention s'il y a plusieurs variables explicatives, les coeffcients et statistiques de test appliqués sont de type I.    \n- Applique la fonction `anova()` du package `{stats}` : Permet d'afficher facilement le tableau des coefficients mais type I aussi    \n- Prendre la fonction `Anova()` du package `{car}` : Même chose que précédent mais type II (et même III s'il y a une intéraction)    \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nmodele_lineaire_petale\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = Petal.Width ~ Petal.Length, data = iris)\n\nCoefficients:\n (Intercept)  Petal.Length  \n     -0.3631        0.4158  \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(modele_lineaire_petale)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = Petal.Width ~ Petal.Length, data = iris)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.56515 -0.12358 -0.01898  0.13288  0.64272 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  -0.363076   0.039762  -9.131  4.7e-16 ***\nPetal.Length  0.415755   0.009582  43.387  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2065 on 148 degrees of freedom\nMultiple R-squared:  0.9271,\tAdjusted R-squared:  0.9266 \nF-statistic:  1882 on 1 and 148 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\nanova(modele_lineaire_petale)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nResponse: Petal.Width\n              Df Sum Sq Mean Sq F value    Pr(>F)    \nPetal.Length   1  80.26  80.260  1882.5 < 2.2e-16 ***\nResiduals    148   6.31   0.043                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\ncar::Anova(modele_lineaire_petale)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type II tests)\n\nResponse: Petal.Width\n             Sum Sq  Df F value    Pr(>F)    \nPetal.Length  80.26   1  1882.5 < 2.2e-16 ***\nResiduals      6.31 148                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\nPour voir la différence entre les deux `anova` il faut ajouter des variables.  \n  \nLa sortie `summary()` nous dit que le modèle est significatif (`p-value: < 2.2e-16`) mais il faut vérifier qu'il est valide.  \n  \n## 4^ème^ étape : Validation du modèle  \nLe modèle est accepté si les **résidus** suivent une **loi normale**.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nmodele_lineaire_petale$residuals |> \n  shapiro.test()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tShapiro-Wilk normality test\n\ndata:  modele_lineaire_petale$residuals\nW = 0.98378, p-value = 0.07504\n```\n\n\n:::\n:::\n\n  \nLes résidus suivent une loi normale (`p-valeur` > 0.05 -> impossible de rejeter l'hypothèse nulle selon laquelle les données suivent une loi normale).  \n  \nIl est aussi bien de visualiser le modèle grâce à la fonction `plot()`.  \n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(modele_lineaire_petale)\n```\n\n::: {.cell-output-display}\n![La courbe rouge doit être la plus proche de la droite en pointillée](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![Les points doivent suivre la première diagonale en pointillée](index_files/figure-html/unnamed-chunk-13-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![La courbe rouge doit être la plus plate possible](index_files/figure-html/unnamed-chunk-13-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![La courbe rouge doit être proche de la droite horizontale en pointillée](index_files/figure-html/unnamed-chunk-13-4.png){width=672}\n:::\n:::\n\n\n  \n## 5^ème^ étape : Réalisation d'un graphique résumé  \nLe nuage de points avec une droite est la meilleur représentation.  \nLa droite peut-être réalisé grâce à la fonction `geom_abline()` du package `{ggplot2}` et les paramètres du modèle linéaire ajusté (`modele_lineaire_petale`) ou automatiquement avec la fonction `geom_smooth()` du même package en précisant l'argument `method = \"lm\"`.  \nL'équation est affiché sur le graphique grâce à la fonction `stat_regline_equation()` du package `{ggpubr}`.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris) +\n  aes(x = Petal.Length, y = Petal.Width) +\n  geom_point() +\n  geom_abline(\n    slope = modele_lineaire_petale$coefficients[[2]],\n    intercept = modele_lineaire_petale$coefficients[[1]],\n    color = \"red\",\n    linewidth = 2\n  ) +\n  geom_smooth(method = \"lm\") +\n  ggpubr::stat_regline_equation() +\n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}