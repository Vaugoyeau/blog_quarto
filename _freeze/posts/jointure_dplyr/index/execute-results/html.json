{
  "hash": "b3bc1e0cb68fee21ea783b439945015e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Jointure de tables avec `{dplyr}`\"\nauthor: \"Marie Vaugoyeau\"\ndate: \"2024/06/25\"\ndate-format: \"D MMMM YYYY\"\ncategories: [twitch, Rnewbies, tidyverse, analyse de donnÃ©es]\ntoc: true\ntoc-title: Sur cette page\n---\n\n\n[![](joint.png){fig-align=\"center\"}](https://500px.com/p/antoinemach?view=photos)\n\n::: {.callout-note icon=\"false\"}\n[**Twitch du 25 juin 2024**](https://www.twitch.tv/videos/2181295529).  \nLe son est en double au dÃ©but mais cela s'arrÃªte au bout de 2 minutes, dÃ©solÃ©e pour le soucis ðŸ˜…   \n   \nCode disponible sur [GitHub](https://github.com/Vaugoyeau/twitch_jointure_dplyr).  \n:::\n\n# Les donnÃ©es  \n## Import des packages  \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nâ”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\nâœ” dplyr     1.1.4     âœ” readr     2.1.5\nâœ” forcats   1.0.0     âœ” stringr   1.5.1\nâœ” ggplot2   3.5.0     âœ” tibble    3.2.1\nâœ” lubridate 1.9.3     âœ” tidyr     1.3.1\nâœ” purrr     1.0.2     \nâ”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\nâœ– dplyr::filter() masks stats::filter()\nâœ– dplyr::lag()    masks stats::lag()\nâ„¹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n## TempÃ©rature quotidienne  \nLes donnÃ©es sont [les tempÃ©ratures quotidiennes dÃ©partementales](https://www.data.gouv.fr/fr/datasets/temperature-quotidienne-departementale-depuis-janvier-2018/) tÃ©lÃ©chargÃ©e directement depuis le site.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# import des donnÃ©es\ntemperature <- read_delim(\"\n\", delim = \";\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 0 Columns: 0\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\n# ajout mois et annÃ©e\ntemperature <- read_delim(\"https://www.data.gouv.fr/fr/datasets/r/dd0df06a-85f2-4621-8b8b-5a3fe195bcd7\", delim = \";\") |>\n  mutate(\n    mois = month(date_obs),\n    annee = year(date_obs)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 227808 Columns: 6\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \";\"\nchr  (2): code_insee_departement, departement\ndbl  (3): tmin, tmax, tmoy\ndate (1): date_obs\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\n# calcul des valeurs mensuelles\ntemperature <- read_delim(\"https://www.data.gouv.fr/fr/datasets/r/dd0df06a-85f2-4621-8b8b-5a3fe195bcd7\", delim = \";\") |>\n  mutate(\n    mois = month(date_obs),\n    annee = year(date_obs)\n  ) |> \n  group_by(departement, mois, annee) |> \n  summarise(\n    tmin = min(tmin, na.rm = TRUE),\n    tmax = max(tmax, na.rm = TRUE),\n    tmoy = mean(tmoy, na.rm = TRUE)\n  ) |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 227808 Columns: 6\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \";\"\nchr  (2): code_insee_departement, departement\ndbl  (3): tmin, tmax, tmoy\ndate (1): date_obs\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n`summarise()` has grouped output by 'departement', 'mois'. You can override using the `.groups` argument.\n```\n\n\n:::\n:::\n\n\n\n## DensitÃ© de population par dÃ©partements  \nAinsi que les [donnÃ©es de densitÃ©s par dÃ©partements](https://www.insee.fr/fr/statistiques/6683035?sommaire=6683037).  \n\n::: {.cell}\n\n```{.r .cell-code}\ndownload.file(\"https://www.insee.fr/fr/statistiques/fichier/6683035/ensemble.zip\", destfile = \"data_raw/insee.zip\", mode = \"wb\") \n\nunzip(\"data_raw/insee.zip\",exdir = \"data_raw\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninfo_departement <- read_delim(\"data_raw/donnees_departements.csv\", delim =\";\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 100 Columns: 9\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \";\"\nchr (4): CODREG, REG, CODDEP, DEP\ndbl (5): NBARR, NBCAN, NBCOM, PMUN, PTOT\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfile.remove(list.files(\"data_raw\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in file.remove(list.files(\"data_raw\")): impossible d'effacer le fichier\n'donnees_departements.csv', Ã  cause de 'No such file or directory'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n# ConcatÃ©nation de tables  \n## Pourquoi ?  \nPour coupler des informations prÃ©sentes dans diffÃ©rentes tables pour explorer le lien, par exemple les variations de tempÃ©ratures en fonction de la densitÃ© de population.  \n  \n## ProblÃ¨me  \nPour que les jointures se passent bien, il faut que les informations prÃ©sentes dans une table correspondent Ã  celles prÃ©sentes dans l'autre !  \n  \n## DiffÃ©rents types de jointures  \nPrenons deux tables :   \n\n::: {.cell}\n\n```{.r .cell-code}\n(A <- tibble(\n  id = letters[1:3],\n  w = c(5, 9, 7),\n  x= c(1, 4, 8)\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 3\n  id        w     x\n  <chr> <dbl> <dbl>\n1 a         5     1\n2 b         9     4\n3 c         7     8\n```\n\n\n:::\n\n```{.r .cell-code}\n(B <- tibble(\n  id = letters[c(1, 2, 4)],\n  y = c(4, 7, 6),\n  z = c(2, 8, 6)\n  ) \n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 3\n  id        y     z\n  <chr> <dbl> <dbl>\n1 a         4     2\n2 b         7     8\n3 d         6     6\n```\n\n\n:::\n:::\n\n  \nOn veut avoir les informations w, x, y, z pour tous les individus -> **jointure totale** avec `full_join()` de `{dplyr}`  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nfull_join(A, B)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 5\n  id        w     x     y     z\n  <chr> <dbl> <dbl> <dbl> <dbl>\n1 a         5     1     4     2\n2 b         9     4     7     8\n3 c         7     8    NA    NA\n4 d        NA    NA     6     6\n```\n\n\n:::\n:::\n\n \nOn veut que les lignes des individus prÃ©sents dans les deux tableaux -> **jointure interne** avec `inner_join()` de `{dplyr}`  \n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(A, B)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 5\n  id        w     x     y     z\n  <chr> <dbl> <dbl> <dbl> <dbl>\n1 a         5     1     4     2\n2 b         9     4     7     8\n```\n\n\n:::\n:::\n\n  \nOn veut toutes les caractÃ©ristiques disponibles pour les individus d'une des deux tables -> **jointure Ã  gauche** ou **Ã  droite** avec `left_join()` et `right_join()` de `{dplyr}`. Le sens de la jointure a une influence dans l'ordre des tables mais fait la mÃªme chose si on inverse l'ordre, seules les colonnes ne seront pas dans le mÃªme ordre.  \n  \n\n::: callout-note\n## Pour rÃ©organiser les colonnes  \n\nIl est possible d'utiliser la fonction `relocate()` du package `{dplyr}`.  \n:::   \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join(A, B)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 5\n  id        w     x     y     z\n  <chr> <dbl> <dbl> <dbl> <dbl>\n1 a         5     1     4     2\n2 b         9     4     7     8\n3 c         7     8    NA    NA\n```\n\n\n:::\n\n```{.r .cell-code}\nright_join(B, A)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 5\n  id        y     z     w     x\n  <chr> <dbl> <dbl> <dbl> <dbl>\n1 a         4     2     5     1\n2 b         7     8     9     4\n3 c        NA    NA     7     8\n```\n\n\n:::\n\n```{.r .cell-code}\n# rÃ©organisation des colonnes\nright_join(B, A) |> \n  relocate(id, letters[23:26])\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 5\n  id        w     x     y     z\n  <chr> <dbl> <dbl> <dbl> <dbl>\n1 a         5     1     4     2\n2 b         9     4     7     8\n3 c         7     8    NA    NA\n```\n\n\n:::\n\n```{.r .cell-code}\nleft_join(B, A)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 5\n  id        y     z     w     x\n  <chr> <dbl> <dbl> <dbl> <dbl>\n1 a         4     2     5     1\n2 b         7     8     9     4\n3 d         6     6    NA    NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# rÃ©organisation des colonnes\nleft_join(B, A) |> \n  relocate(letters[23:26], .after = id)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 5\n  id        w     x     y     z\n  <chr> <dbl> <dbl> <dbl> <dbl>\n1 a         5     1     4     2\n2 b         9     4     7     8\n3 d        NA    NA     6     6\n```\n\n\n:::\n\n```{.r .cell-code}\nright_join(A, B)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 5\n  id        w     x     y     z\n  <chr> <dbl> <dbl> <dbl> <dbl>\n1 a         5     1     4     2\n2 b         9     4     7     8\n3 d        NA    NA     6     6\n```\n\n\n:::\n:::\n\n\nOn veut les individus qui ne sont pas prÃ©sent dans l'autre table -> **anti-jointure** avec `anti_join()` de `{dplyr}`.  \nL'ordre Ã  son importance, ce sont les individus de la premiÃ¨re table qui ne sont pas prÃ©sent dans la deuxiÃ¨me qui sortent.  \n\n::: {.cell}\n\n```{.r .cell-code}\nanti_join(A, B)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 Ã— 3\n  id        w     x\n  <chr> <dbl> <dbl>\n1 c         7     8\n```\n\n\n:::\n\n```{.r .cell-code}\nanti_join(B, A)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 Ã— 3\n  id        y     z\n  <chr> <dbl> <dbl>\n1 d         6     6\n```\n\n\n:::\n:::\n\n\n\n# PrÃ©paration des donnÃ©es en amont \n## Identification de la clÃ© de jointure  \nSi pas dÃ©faut les fonctions prennent comme clÃ© de jointure les colonnes qui ont le mÃªme nom, ce n'est pas nÃ©cessairement ce que l'on veut obtenir.  \nLa clÃ© peut Ãªtre basÃ© sur une ou plusieurs colonnes.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(info_departement)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 100\nColumns: 9\n$ CODREG <chr> \"84\", \"32\", \"84\", \"93\", \"93\", \"93\", \"84\", \"44\", \"76\", \"44\", \"76â€¦\n$ REG    <chr> \"Auvergne-RhÃ´ne-Alpes\", \"Hauts-de-France\", \"Auvergne-RhÃ´ne-Alpeâ€¦\n$ CODDEP <chr> \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11â€¦\n$ DEP    <chr> \"Ain\", \"Aisne\", \"Allier\", \"Alpes-de-Haute-Provence\", \"Hautes-Alâ€¦\n$ NBARR  <dbl> 4, 5, 3, 4, 2, 2, 3, 4, 3, 3, 3, 3, 4, 4, 3, 3, 5, 3, 3, 3, 4, â€¦\n$ NBCAN  <dbl> 23, 21, 19, 15, 15, 27, 17, 19, 13, 17, 19, 23, 29, 25, 15, 19,â€¦\n$ NBCOM  <dbl> 393, 799, 317, 198, 162, 163, 335, 449, 327, 431, 433, 285, 119â€¦\n$ PMUN   <dbl> 657856, 529374, 335628, 165451, 140605, 1097410, 329325, 269701â€¦\n$ PTOT   <dbl> 673801, 541176, 344455, 170060, 144981, 1111390, 338147, 275801â€¦\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 7,488\nColumns: 6\n$ departement <chr> \"Ain\", \"Ain\", \"Ain\", \"Ain\", \"Ain\", \"Ain\", \"Ain\", \"Ain\", \"Aâ€¦\n$ mois        <dbl> 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3â€¦\n$ annee       <dbl> 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2018, 2019, 2020â€¦\n$ tmin        <dbl> -1.7, -6.8, -5.2, -8.9, -7.7, -5.5, -6.3, -12.1, -5.9, -3.â€¦\n$ tmax        <dbl> 15.7, 11.4, 15.7, 13.4, 13.7, 17.4, 16.0, 11.4, 18.7, 19.8â€¦\n$ tmoy        <dbl> 7.559677, 2.195161, 4.374194, 2.093548, 1.266129, 4.827419â€¦\n```\n\n\n:::\n:::\n\n  \nIci : `DEP` == `departement`    \n  \n## MÃªme type d'objets  \nLes donnÃ©es doivent-Ãªtre de mÃªme type donc la vÃ©rification de la classe des clÃ©s est indispensable.  \n\n::: {.cell}\n\n```{.r .cell-code}\nclass(info_departement$DEP) == class(temperature$departement)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n  \n## PrÃ©sence de doublons  \nLa dÃ©tection des doublons se fait facilement grÃ¢ce Ã  la fonction `count()` de `{dplyr}`.  \n\n::: {.cell}\n\n```{.r .cell-code}\ninfo_departement |> \n  count(DEP) |> \n  arrange(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 Ã— 2\n   DEP                         n\n   <chr>                   <int>\n 1 Ain                         1\n 2 Aisne                       1\n 3 Allier                      1\n 4 Alpes-Maritimes             1\n 5 Alpes-de-Haute-Provence     1\n 6 Ardennes                    1\n 7 ArdÃ¨che                     1\n 8 AriÃ¨ge                      1\n 9 Aube                        1\n10 Aude                        1\n# â„¹ 90 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\ntemperature |> \n  count(departement) |> \n  filter(n != 77)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 96 Ã— 2\n   departement                 n\n   <chr>                   <int>\n 1 Ain                        78\n 2 Aisne                      78\n 3 Allier                     78\n 4 Alpes-Maritimes            78\n 5 Alpes-de-Haute-Provence    78\n 6 Ardennes                   78\n 7 ArdÃ¨che                    78\n 8 AriÃ¨ge                     78\n 9 Aube                       78\n10 Aude                       78\n# â„¹ 86 more rows\n```\n\n\n:::\n:::\n\n\n\n## PrÃ©sence de valeurs manquantes  \nL'utilisation conjuguÃ©e de la fonction `is.na()` du package `{base}` dans la fonction `filter()` de `{dplyr}` permet de trier facilement les lignes avec des valeurs manquantes.  \n\n::: {.cell}\n\n```{.r .cell-code}\ninfo_departement |> \n  filter(is.na(DEP))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 Ã— 9\n# â„¹ 9 variables: CODREG <chr>, REG <chr>, CODDEP <chr>, DEP <chr>, NBARR <dbl>,\n#   NBCAN <dbl>, NBCOM <dbl>, PMUN <dbl>, PTOT <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\ntemperature |> \n  filter(is.na(departement))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 Ã— 6\n# â„¹ 6 variables: departement <chr>, mois <dbl>, annee <dbl>, tmin <dbl>,\n#   tmax <dbl>, tmoy <dbl>\n```\n\n\n:::\n:::\n\n\nCe n'est pas nÃ©cessairement un problÃ¨me **d'avoir des doublons** ou **des valeurs manquantes** mais il faut que cela correspondent Ã  ce que l'on souhaite faire.  \n  \n# Jointure total avec `full_join()` \n## RÃ©alisation de la jointure  \n\n::: {.cell}\n\n```{.r .cell-code}\njointure_total <- full_join(\n  info_departement,\n  temperature,\n  by = join_by(DEP == departement)\n  )\n```\n:::\n\n  \n## VÃ©rification de la table crÃ©e  \nCalcul de la taille attendue  \n\n::: {.cell}\n\n```{.r .cell-code}\ndim(info_departement)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100   9\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7488    6\n```\n\n\n:::\n\n```{.r .cell-code}\n# calcul du nombre de colonnes attendue\nncol(info_departement) + ncol(temperature) - 1 == ncol(jointure_total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# vÃ©rification du nombre de lignes\nnrow(temperature) == nrow(jointure_total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n  \n## Recherche des `NA`  \n\n::: {.cell}\n\n```{.r .cell-code}\njointure_total |> \n  filter(is.na(CODREG))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 Ã— 14\n# â„¹ 14 variables: CODREG <chr>, REG <chr>, CODDEP <chr>, DEP <chr>,\n#   NBARR <dbl>, NBCAN <dbl>, NBCOM <dbl>, PMUN <dbl>, PTOT <dbl>, mois <dbl>,\n#   annee <dbl>, tmin <dbl>, tmax <dbl>, tmoy <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\njointure_total |> \n  filter(is.na(mois)) |> \n  View()\n```\n:::\n\n\n## Utilisation de l'anti-jointure  \nPossibilitÃ© d'utiliser l'anti-jointure pour identifier les lignes Ã  problÃ¨me  \n\n::: {.cell}\n\n```{.r .cell-code}\nanti_join(\n  info_departement,\n  temperature,\n  by = join_by(DEP == departement)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 9\n  CODREG REG        CODDEP DEP        NBARR NBCAN NBCOM   PMUN   PTOT\n  <chr>  <chr>      <chr>  <chr>      <dbl> <dbl> <dbl>  <dbl>  <dbl>\n1 01     Guadeloupe 971    Guadeloupe     2    21    32 383559 388727\n2 02     Martinique 972    Martinique     4    NA    34 361225 365734\n3 03     Guyane     973    Guyane         2    NA    22 285133 287355\n4 04     La RÃ©union 974    La RÃ©union     4    25    24 863083 872635\n```\n\n\n:::\n\n```{.r .cell-code}\nanti_join(\n  temperature,\n  info_departement,\n  by = join_by(departement == DEP)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 Ã— 6\n# â„¹ 6 variables: departement <chr>, mois <dbl>, annee <dbl>, tmin <dbl>,\n#   tmax <dbl>, tmoy <dbl>\n```\n\n\n:::\n:::\n\n  \n# Jointure interne avec `inner_join()`  \n## CrÃ©ation de la jointure la plus stricte  \n\n::: {.cell}\n\n```{.r .cell-code}\njointure_interne <- inner_join(\n  info_departement,\n  temperature,\n  by = join_by(DEP == departement)\n)\n\n# mÃªme rÃ©sultat avec la jointure Ã  droite\njointure_a_droite <- right_join(\n  info_departement,\n  temperature,\n  by = join_by(DEP == departement)\n)\n\n# vÃ©rification  \nidentical(jointure_a_droite, jointure_interne)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n  \n## VÃ©rification de la jointure interne  \n\n::: {.cell}\n\n```{.r .cell-code}\njointure_a_droite |> \n  count(DEP) |> \n  filter(n != 77)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 96 Ã— 2\n   DEP                         n\n   <chr>                   <int>\n 1 Ain                        78\n 2 Aisne                      78\n 3 Allier                     78\n 4 Alpes-Maritimes            78\n 5 Alpes-de-Haute-Provence    78\n 6 Ardennes                   78\n 7 ArdÃ¨che                    78\n 8 AriÃ¨ge                     78\n 9 Aube                       78\n10 Aude                       78\n# â„¹ 86 more rows\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}