{
  "hash": "676ef176f9721781963874b008a3c631",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Sélection d'un modèle linéaire\"\nauthor: \"Marie Vaugoyeau\"\ndate: \"2025/01/21\"\ndate-format: \"D MMMM YYYY\"\ncategories: [twitch, Rnewbies, analyse de données, statistiques]\ntoc: true\ntoc-title: Sur cette page\n---\n\n\n[![](fontaine.png){fig-align=\"center\"}](https://500px.com/p/antoinemach?view=photos)\n\n::: {.callout-note icon=\"false\"}\n[**Twitch du 21 janvier 2025**](https://www.twitch.tv/videos/2359516372).\\\n\nCode disponible sur [GitHub](https://github.com/Vaugoyeau/twitch_model_lineaire).  \n:::\n  \n⚠️ Cet article fait suite à celui sur la [régression linéaire](https://mvaugoyeau.netlify.app/posts/regression_lineaire/). N'hésites pas à aller voir si tu n'es pas habitué.e à manipuler les modèles linéaires ⚠️\n  \n# import des packages  \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n```\n:::\n\n\n# Définition de la `régression linéaire`  \n\n**Objectif** : Trouver une équation de type linéaire qui permet d'expliquer une **variable réponse quantitative** par **une ou plusieurs variable(s) explicative(s)**.   \n\n:::callout-note\n## Différence entre régression linéaire et modèle linéaire  \n\nIl n'y en a pas !  \nCertaines personnes parlent de **modèle de régression linéaire**.  \n:::\n\nL'équation est de la forme : $$ Y = a_1X_1 + a_2X_2 + ... + a_nX_n +  b $$ \n\nAvec a~i~ : la pente (ou coefficient directeur) associé à la variable X~i~ et b : l'ordonnée à l'origine ou **intecept** (en anglais).     \n \n# Les données  \nLes données utilisées sont celles du jeu de données `penguins` du package `{palmerpenguins}`.  \nPlus d'information sur la page d'aide `help(penguins)`.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 344\nColumns: 8\n$ species           <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…\n$ island            <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…\n$ bill_length_mm    <dbl> 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     <dbl> 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm <int> 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       <int> 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               <fct> male, female, female, NA, female, male, female, male…\n$ year              <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n```\n\n\n:::\n:::\n\n\n# Réalisation d'un modèl linéaire  \n## 1^ère^ étape : Choix des variables utilisées  \n  \nDans cette exemple, la **variable réponse** est `body_mass_g` et les **variables explicatives** sont les caractéristiques morphologiques mesurées : `bill_length_mm`, `bill_depth_mm` et `flipper_length_mm`.  \n  \n::: callout-note\nLes données ajoutées dans un model doit avoir un sens.  \nOn ne peux pas ajouter toutes les variables **juste pour voir** !  \n:::\n\nLes risques à mettre toutes les variables possibles dans un modèle :  \n\n- Impossibilité d'expliquer le modèle dans la réalité (*expl : l'âge du capitaine*)  \n- Sur ou sous ajustement (aussi appelé sur ou sous apprentissage et en anglais *over or underfitting*)  \n![](img/Overfitting.png)  \n[@educative](https://www.educative.io/answers/overfitting-and-underfitting)  \n  \nSur le graphique :  \n\n- le schéma de gauche montre un **sous-ajustement**, c'est-à-dire que la droite ne prend pas en compte les variations des données et **simplifie trop**.  \n- le schéma du milieu montre un **bon ajustement** aux données.  \n- le schéma de droite montre un **sur-ajustement**. Le courbe ne permet pas de prendre en compte de nouvelles données.  \n  \n## 2^ème^ étape : Vérifier les limites de construction du modèle       \nLes données doivent être indépendantes et suivre (ou être approximées par) des lois normales.  \n  \nTest de Shapiro-Wilk\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(\n  .x = penguins |> \n    select(where(is.numeric), - year),\n  .f = shapiro.test\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$bill_length_mm\n\n\tShapiro-Wilk normality test\n\ndata:  .x[[i]]\nW = 0.97485, p-value = 1.12e-05\n\n\n$bill_depth_mm\n\n\tShapiro-Wilk normality test\n\ndata:  .x[[i]]\nW = 0.97258, p-value = 4.419e-06\n\n\n$flipper_length_mm\n\n\tShapiro-Wilk normality test\n\ndata:  .x[[i]]\nW = 0.95155, p-value = 3.54e-09\n\n\n$body_mass_g\n\n\tShapiro-Wilk normality test\n\ndata:  .x[[i]]\nW = 0.95921, p-value = 3.679e-08\n```\n\n\n:::\n:::\n\n  \n::: callout-note\nSelon le test de Shapiro-Wilk, les données ne suivent pas des lois normales  \n:::\n  \nReprésentation graphique  \n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  select(\n    where(is.numeric),\n    - year\n  ) |> \n  pivot_longer(everything()) |> \n  ggplot() +\n  aes(sample = value) +\n  geom_qq() +\n  geom_qq_line() +\n  facet_wrap(~ name, scales = \"free\") +\n  theme_bw()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 8 rows containing non-finite outside the scale range\n(`stat_qq()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 8 rows containing non-finite outside the scale range\n(`stat_qq_line()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n  \nIci la normalité est acceptable, surtout qu'il y a bien plus de 30 données.  \n  \n:::callout-note  \nLe modèle linéaire est assez résistant à l'absence de normalité et il est possible de le faire en prenant en compte [**la loi des grands nombres**](https://fr.wikipedia.org/wiki/Loi_des_grands_nombres).  \n:::\n  \nSi tu as déjà un modèle linéaire, tu as dû entendre parler de multicolinéarité (comme on m'a posé la question lors du [live](https://www.twitch.tv/videos/2359516372) 😊)  \n  \n::: callout-warning\n## Définitions : multicolinéarité ou corrélation   \n\nLa colinéarité est une corrélation entre variables indépendantes.  \nQuand plusieurs variables sont concernées on parle de multicolinéarité.  \n:::\n  \nIci il est intéressant de regarder la multicolinéarité même si elle est traité plus loin !  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  select(where(is.numeric), - year) |>\n  drop_na() |> \n  cor() |> \n  corrplot::corrplot.mixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n  \n## 3^ème^ étape : Création du modèle linéaire  \nPlusieurs packages ont des fonctions qui permettent de réaliser un modèle linéaire.  \nIci je vais rester sur la fonction `lm()` du package `{stats}` automatiquement chargé dans l'environnement.  \nCette fonction prend comme premier argument la `formula`, c'est-à-dire la formule de type `y ~ x` et en deuxième argument `data`, le jeu de données utilisé.  \n\n::: {.cell}\n\n```{.r .cell-code}\nlm_body_mass <- lm(\n  body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm,\n  data = penguins\n)\n```\n:::\n\n  \nPour accéder aux coefficients, il y a plusieurs solutions :  \n\n- Rappeler le nom du modèle : Ne donne pas les statistiques de test    \n- Utiliser la fonction `summary()` du package `{base}` : Le plus complet      \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nlm_body_mass\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm, \n    data = penguins)\n\nCoefficients:\n      (Intercept)     bill_length_mm      bill_depth_mm  flipper_length_mm  \n        -6424.765              4.162             20.050             50.269  \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(lm_body_mass)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm, \n    data = penguins)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1054.94  -290.33   -21.91   239.04  1276.64 \n\nCoefficients:\n                   Estimate Std. Error t value Pr(>|t|)    \n(Intercept)       -6424.765    561.469 -11.443   <2e-16 ***\nbill_length_mm        4.162      5.329   0.781    0.435    \nbill_depth_mm        20.050     13.694   1.464    0.144    \nflipper_length_mm    50.269      2.477  20.293   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 393.4 on 338 degrees of freedom\n  (2 observations effacées parce que manquantes)\nMultiple R-squared:  0.7615,\tAdjusted R-squared:  0.7594 \nF-statistic: 359.7 on 3 and 338 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\n  \nPour aller plus loin :  \n  \n- Utilisation de la fonction `anova()` du package `{stats}` : Permet d'afficher facilement le tableau des coefficients     \n- Prendre la fonction `Anova()` du package `{car}` : Même chose que précédent mais type II (et même III s'il y a une interaction)    \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nanova(lm_body_mass)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nResponse: body_mass_g\n                   Df   Sum Sq  Mean Sq F value    Pr(>F)    \nbill_length_mm      1 77669072 77669072  501.84 < 2.2e-16 ***\nbill_depth_mm       1 25591770 25591770  165.36 < 2.2e-16 ***\nflipper_length_mm   1 63735497 63735497  411.81 < 2.2e-16 ***\nResiduals         338 52311359   154767                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\ncar::Anova(lm_body_mass)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type II tests)\n\nResponse: body_mass_g\n                    Sum Sq  Df  F value Pr(>F)    \nbill_length_mm       94393   1   0.6099 0.4354    \nbill_depth_mm       331766   1   2.1436 0.1441    \nflipper_length_mm 63735497   1 411.8149 <2e-16 ***\nResiduals         52311359 338                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n  \n## 4^ème^ étape : Validation du modèle  \nLe modèle est accepté si les **résidus** suivent une **loi normale**.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nlm_body_mass$residuals |> \n  shapiro.test()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tShapiro-Wilk normality test\n\ndata:  lm_body_mass$residuals\nW = 0.99368, p-value = 0.164\n```\n\n\n:::\n:::\n\n  \n  \nLes résidus suivent une loi normale (`p-valeur` > 0.05 -> impossible de rejeter l'hypothèse nulle selon laquelle les données suivent une loi normale).  \n  \nIl est aussi bien de visualiser le modèle grâce à la fonction `plot()`.  \n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(lm_body_mass)\n```\n\n::: {.cell-output-display}\n![La courbe rouge doit être la plus proche de la droite en pointillée](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![Les points doivent suivre la première diagonale en pointillée](index_files/figure-html/unnamed-chunk-10-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![La courbe rouge doit être la plus plate possible](index_files/figure-html/unnamed-chunk-10-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![La courbe rouge doit être proche de la droite horizontale en pointillée](index_files/figure-html/unnamed-chunk-10-4.png){width=672}\n:::\n:::\n\n  \nEt la multicolinéarité ?  \n\n::: {.cell}\n\n```{.r .cell-code}\ncar::vif(lm_body_mass)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   bill_length_mm     bill_depth_mm flipper_length_mm \n         1.865090          1.611292          2.673338 \n```\n\n\n:::\n:::\n\n  \nIl y a pas de multicolinéarité lorsque les facteurs d'inflation de la variance (en anglais *variance inflation factor (VIF)*) sont à `1`.  \n\n  \n:::callout-note  \n## Influence de la multicolinéarité  \n\nSi les **FIV** sont supérieurs à 1, la variable est corrélée aux autre et son influence est \"augmentée\".   \nA quel valeur est-ce grave ?  \nPour [Paul ALLISON](https://statisticalhorizons.com/multicollinearity/) au delà de `2,5` c'est un signe d'inquiétude. Pour d'autres personnes, c'est à partir de `5`.  \n**Mon conseil** : Simplifions le modèle et voyons après !  \n::: \n  \n  \n## 5^ème^ étape : Sélection de modèle  \nIci, réalisation d'une sélection descendante qui revient à supprimer les variables les moins significatives.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nlm_body_mass_2 <- lm(\n  body_mass_g ~ bill_depth_mm + flipper_length_mm,\n  data = penguins\n)\n\nsummary(lm_body_mass_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = body_mass_g ~ bill_depth_mm + flipper_length_mm, \n    data = penguins)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1029.78  -271.45   -23.58   245.15  1275.97 \n\nCoefficients:\n                   Estimate Std. Error t value Pr(>|t|)    \n(Intercept)       -6541.907    540.751 -12.098   <2e-16 ***\nbill_depth_mm        22.634     13.280   1.704   0.0892 .  \nflipper_length_mm    51.541      1.865  27.635   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 393.2 on 339 degrees of freedom\n  (2 observations effacées parce que manquantes)\nMultiple R-squared:  0.761,\tAdjusted R-squared:  0.7596 \nF-statistic: 539.8 on 2 and 339 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\nanova(lm_body_mass, lm_body_mass_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nModel 1: body_mass_g ~ bill_length_mm + bill_depth_mm + flipper_length_mm\nModel 2: body_mass_g ~ bill_depth_mm + flipper_length_mm\n  Res.Df      RSS Df Sum of Sq      F Pr(>F)\n1    338 52311359                           \n2    339 52405752 -1    -94393 0.6099 0.4354\n```\n\n\n:::\n\n```{.r .cell-code}\nAIC(lm_body_mass, lm_body_mass_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               df      AIC\nlm_body_mass    5 5063.320\nlm_body_mass_2  4 5061.937\n```\n\n\n:::\n:::\n\n\nPour comparer deux modèles, j'utilise ici l'AIC.  \n\n::: callout-note\n## AIC : Critère d'Information d'Akaike (en anglais *Akaike information criterion*)  \n  \nPermet de comparer deux modèles proches (même données et une ou deux variables en plus ou en moins) pour choisir le plus significatif, c'est-à-dire celui qui a la la valeur d'AIC la plus faible. \n\n**Attention** : si la différence est inférieure à 2, il faut faire le choix de parcimonie, c'est-à-dire de préférer le modèle le plus simple (avec le moins de variables explicatives).  \n:::\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nlm_body_mass_3 <- lm(\n  body_mass_g ~ flipper_length_mm,\n  data = penguins\n)\n\nsummary(lm_body_mass_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = body_mass_g ~ flipper_length_mm, data = penguins)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1058.80  -259.27   -26.88   247.33  1288.69 \n\nCoefficients:\n                   Estimate Std. Error t value Pr(>|t|)    \n(Intercept)       -5780.831    305.815  -18.90   <2e-16 ***\nflipper_length_mm    49.686      1.518   32.72   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 394.3 on 340 degrees of freedom\n  (2 observations effacées parce que manquantes)\nMultiple R-squared:  0.759,\tAdjusted R-squared:  0.7583 \nF-statistic:  1071 on 1 and 340 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\nanova(lm_body_mass_2, lm_body_mass_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nModel 1: body_mass_g ~ bill_depth_mm + flipper_length_mm\nModel 2: body_mass_g ~ flipper_length_mm\n  Res.Df      RSS Df Sum of Sq      F  Pr(>F)  \n1    339 52405752                              \n2    340 52854796 -1   -449044 2.9048 0.08924 .\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nAIC(lm_body_mass_2, lm_body_mass_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               df      AIC\nlm_body_mass_2  4 5061.937\nlm_body_mass_3  3 5062.855\n```\n\n\n:::\n:::\n\n\nLe modèle le plus simple avec juste la longueur de la nageoire serait meilleur.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_body_mass_3$residuals |> \n  shapiro.test()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tShapiro-Wilk normality test\n\ndata:  lm_body_mass_3$residuals\nW = 0.99301, p-value = 0.1123\n```\n\n\n:::\n:::\n\n  \nLes résidus suivants une loi normale, le modèle est validé.  \n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(lm_body_mass_3)\n```\n\n::: {.cell-output-display}\n![La courbe rouge doit être la plus proche de la droite en pointillée](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![Les points doivent suivre la première diagonale en pointillée](index_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![La courbe rouge doit être la plus plate possible](index_files/figure-html/unnamed-chunk-15-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![La courbe rouge doit être proche de la droite horizontale en pointillée](index_files/figure-html/unnamed-chunk-15-4.png){width=672}\n:::\n:::\n\n\nLes sorties graphiques de la fonction `plot()` valide le modèle aussi.  \n\nIl ne reste donc plus qu'à valoriser le modèle trouvé via un graphique.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins) +\n  aes(x = flipper_length_mm, y = body_mass_g) +\n  geom_point(alpha = 0.4) +\n  geom_smooth(method = \"lm\") +\n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nSur le graphique il semble apparaître \"2 groupes\", **un avec une nageoire de moins de 205 mm** et **un avec plus**.  \nIl est possible d'explorer graphiquement cette idée en ajoutant l'espèce en couleur.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(penguins) +\n  aes(x = flipper_length_mm, y = body_mass_g, colour = species) +\n  geom_point(alpha = 0.4) +\n  geom_smooth(method = \"lm\") +\n  theme_classic()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nCréation d'un modèle avec une interaction espèce et longueur de la nageoire. C'est à dire que l'espèce influence le coefficient directeur associée à la longueur de la nageoire comme vu sur le graphique.  \nL'interaction est représenté par `:` mais comme les effets simples doivent être présent dans le modèle, il faut utiliser `*` ainsi `A * B = A + B + A:B` avec `A` et `B` sont les effets simples qui ne doivent pas être supprimé du modèle si l'interaction est significative et `A:B` est l'interaction.  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nlm_body_mass_4 <- lm(\n  body_mass_g ~ flipper_length_mm * species,\n  data = penguins\n)\n\nsummary(lm_body_mass_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = body_mass_g ~ flipper_length_mm * species, data = penguins)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-911.18 -251.93  -31.77  197.82 1144.81 \n\nCoefficients:\n                                    Estimate Std. Error t value Pr(>|t|)    \n(Intercept)                        -2535.837    879.468  -2.883  0.00419 ** \nflipper_length_mm                     32.832      4.627   7.095 7.69e-12 ***\nspeciesChinstrap                    -501.359   1523.459  -0.329  0.74229    \nspeciesGentoo                      -4251.444   1427.332  -2.979  0.00311 ** \nflipper_length_mm:speciesChinstrap     1.742      7.856   0.222  0.82467    \nflipper_length_mm:speciesGentoo       21.791      6.941   3.139  0.00184 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 370.6 on 336 degrees of freedom\n  (2 observations effacées parce que manquantes)\nMultiple R-squared:  0.7896,\tAdjusted R-squared:  0.7864 \nF-statistic: 252.2 on 5 and 336 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\ncar::Anova(lm_body_mass_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnova Table (Type II tests)\n\nResponse: body_mass_g\n                            Sum Sq  Df F value    Pr(>F)    \nflipper_length_mm         24776495   1 180.398 < 2.2e-16 ***\nspecies                    5187807   2  18.886 1.686e-08 ***\nflipper_length_mm:species  1519564   2   5.532  0.004327 ** \nResiduals                 46147424 336                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\nLa fonction `Anova()` du package `{car}` nous permet de voir que l'interaction est significative.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nAIC(lm_body_mass_3, lm_body_mass_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               df      AIC\nlm_body_mass_3  3 5062.855\nlm_body_mass_4  7 5024.443\n```\n\n\n:::\n:::\n\nSelon l'AIC, le modèle avec l'interaction est beaucoup plus intéressant que le modèle simple avec que la longueur de la nageoire.  \n  \nPour connaître la différence entre les espèces il faut faire un test post-hoc pour effectuer une comparaison multiple, ici un test post-hoc de Tukey.  \n  \n::: callout-warning\n## Attention  \n\nUn test post-hoc ne se réalise **que** si la variable concernée est **significative** dans le modèle !  \n::: \n  \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(multcomp)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLe chargement a nécessité le package : mvtnorm\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLe chargement a nécessité le package : survival\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLe chargement a nécessité le package : TH.data\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLe chargement a nécessité le package : MASS\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttachement du package : 'MASS'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nL'objet suivant est masqué depuis 'package:dplyr':\n\n    select\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttachement du package : 'TH.data'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nL'objet suivant est masqué depuis 'package:MASS':\n\n    geyser\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(glht(lm_body_mass_4, linfct = mcp(species=\"Tukey\")))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in mcp2matrix(model, linfct = linfct): covariate interactions found --\ndefault contrast might be inappropriate\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\t Simultaneous Tests for General Linear Hypotheses\n\nMultiple Comparisons of Means: Tukey Contrasts\n\n\nFit: lm(formula = body_mass_g ~ flipper_length_mm * species, data = penguins)\n\nLinear Hypotheses:\n                        Estimate Std. Error t value Pr(>|t|)   \nChinstrap - Adelie == 0   -501.4     1523.5  -0.329  0.94179   \nGentoo - Adelie == 0     -4251.4     1427.3  -2.979  0.00864 **\nGentoo - Chinstrap == 0  -3750.1     1676.7  -2.237  0.06618 . \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n(Adjusted p values reported -- single-step method)\n```\n\n\n:::\n:::\n\n\n::: callout-note\nPour résumer, `Chinstrap` et `Adelie` sont similaires.  \n`Gentoo` est significativement différent de `Adelie` (*p-valeur* < 0.01) et légèrement différent de `Chinstrap` (*p-valeur* = 0.07).  \n  \nSi tu as l'habitude d'utiliser les lettres, `Gentoo` est `a`, `Adelie` est `b` et `Chinstrap` est `ab`.  \n:::  \n  \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}